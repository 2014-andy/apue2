#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <time.h>

time_t before, after;

static void sig_alarm(int signo)
{
	if ((after = time(NULL)) < 0)
		exit(1);
	printf("after - before=%ld\n",after - before);
}

/* The alarm() function allows us to set a timer that will expire at a
 * specified time in the future. When the timer expires, the SIGALRM signal
 * is generated. If we ignore or don't catch this signal, its default action
 * is to terminate the process.
 * #include <unistd.h>
 * unsigned int alarm(unsigned int seconds);
 * 		Returns: 0 or number of seconds until previously set alarm
 * alarm()函数的返回值是0,或者是上一次所设置警报定时器的剩余时间.例如,上一次
 * 设置的超时时间是5,然后在3秒之后再次调用alarm()函数,此时alarm()函数返回的
 * 是2,即离上一次所设置警报的定时器超时还有2秒钟.
 *
 * The seconds value if the number of clock seconds in the future when the
 * signal should be generaed. Be aware that when that time occurs, the
 * signal is generated by the kernel, but there could be additional time
 * before the process gets control to handle the signal, because of
 * processor scheduling delays.
 *
 * There is only one of these alarm clocks per process. If, when we call
 * alarm(), a previously registered alarm clock for the process has not
 * expired, the number of seconds left for that alarm clock is returned as
 * the value of this function. That previously registered alarm clock is
 * replaced by the new value.
 *
 * If a previously registered alarm clock for the process has not yet
 * expired and if the second value is 0, the previous alarm clock is
 * canceled. The number of seconds left for that previous alarm clock is
 * still returned as the value of the function.
 */
int main(void)
{
	int alarm_ret, i, j;
	volatile int k;

	if (signal(SIGALRM, sig_alarm) == SIG_ERR) {
		printf("signal SIGALRM error: %m\n");
		return 1;
	}
	
	/* 获取当前时间点,后面会再获取一次时间点,两者相减,得到这段时间的时间差
	 * 主要是为了验证 alarm() 函数返回的时上一个警报定时器的剩余时间.
	 */
	if ((before = time(NULL)) < 0) {
		printf("time(NULL) error: %m");
		return 1;
	}

	/* 设置警报定时器,并打印alarm()函数的返回值,由于这是第一次调用alarm()
	 * 函数,它返回的应该是 0,打印出来的结果也确实是 0.
	 */
	alarm_ret = alarm(5);
	printf("call alarm(5), the return value is: %u\n", alarm_ret);

	/* 此时只是要消耗一点时间. 将变量 k 声明为 volatile,是借鉴自书中的
	 * Figure 10.8程序,为了阻止编译器对下面循环的优化.
	 */
	for (k = 0, i = 0; i < 80000; ++i)
		for (j = 0; j < 10000; ++j)
			k += i * j;

	/* 再次获取一次时间点,并打印前后两次获取的时间点以及它们的时间差.
	 * 这个时间差可以用来和后面的 alarm() 函数返回值作对比.看alarm()函数
	 * 的返回值是否等于 (5 - 这个时间差).
	 */
	if ((after = time(NULL)) < 0) {
		printf("time(NULL error: %m");
		return 1;
	}
	printf("after = %ld, before = %ld, after - before = %ld\n", 
			after, before, after - before);
	
	/* 再次调用 alarm() 函数,由于上面已经调用过一次 alarm() 函数,其次它将
	 * 返回上一次警报定时器的剩余时间.且新设置的警报定时器会取代上次那个.
	 * 现在警报定时器将在 7 秒之后超时,然后进程收到 SIGALRM 信号.
	 */
	alarm_ret = alarm(7);
	printf("call alarm(7), the return value is: %u\n", alarm_ret);

	/* The pause() function suspends the calling process until a signal
	 * is caught.
	 * #include <unistd.h>
	 * int pause(void);
	 * 		Returns: -1 with errno set to EINTR.
	 * The only time pause() returns is if a signal handler is executed
	 * and that handler returns. In that case, pause() returns -1 with
	 * errno set to EINTR.
	 */
	pause();

	return 0;
}
